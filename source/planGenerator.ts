import {GoogleGenerativeAI} from '@google/generative-ai';
import {PlanningResult, AgentType} from './types.js';
import * as fs from 'fs/promises';
import * as path from 'path';

export class PlanGenerator {
	private genAI: GoogleGenerativeAI;
	private model: any;

	constructor(apiKey: string) {
		this.genAI = new GoogleGenerativeAI(apiKey);
		this.model = this.genAI.getGenerativeModel({
			model: 'gemini-2.0-flash-exp',
		});
	}

	async generatePlan(result: PlanningResult): Promise<string> {
		const prompt = this.buildPromptForAgent(result);

		const response = await this.model.generateContent(prompt);
		const plan = response.response.text();

		return this.formatPlan(result, plan);
	}

	private buildPromptForAgent(result: PlanningResult): string {
		const baseContext = `You are the ${result.agent.name} agent creating a detailed implementation plan.

Task: "${result.query}"

Analysis:
- Type: ${result.analysis.taskType}
- Complexity: ${result.analysis.complexity}
- Estimated Files: ${result.analysis.estimatedFiles}
- Affected Areas: ${result.analysis.affectedAreas.join(', ')}

Your role: ${result.agent.purpose}`;

		switch (result.routing.selectedAgent) {
			case AgentType.Planner:
				return `${baseContext}

Create a detailed, file-by-file implementation plan in markdown format.

Include:
1. **Overview**: Brief summary of what needs to be done
2. **Files to Modify**: List each file with specific changes
3. **Implementation Steps**: Ordered, numbered steps
4. **Dependencies**: What needs to be done first
5. **Testing**: How to verify the changes work

Format as clean markdown. Be specific about line numbers and exact changes where possible.`;

			case AgentType.Architect:
				return `${baseContext}

Create a comprehensive architectural plan in markdown format.

Include:
1. **Architecture Overview**: High-level design decisions
2. **Component Design**: New/modified components and their responsibilities
3. **Data Flow**: How data moves through the system
4. **API/Interface Changes**: New or modified interfaces
5. **Technical Decisions**: Key choices and trade-offs
6. **Implementation Phases**: Break into logical phases
7. **Risks & Mitigations**: Potential issues and solutions

Format as clean markdown with diagrams if helpful (using ASCII/text).`;

			case AgentType.EngineeringTeam:
				return `${baseContext}

Create a large-scale refactoring/implementation plan in markdown format.

Include:
1. **Project Scope**: Full overview of changes
2. **Team Coordination**: Which areas each sub-agent handles
3. **Parallel Workstreams**: What can be done simultaneously
4. **Critical Path**: Dependencies and blockers
5. **Integration Points**: Where components connect
6. **Testing Strategy**: Unit, integration, e2e tests
7. **Rollout Plan**: How to deploy safely
8. **Timeline Estimate**: Rough phases and duration

Format as clean markdown with clear sections.`;

			case AgentType.Explorer:
				return `${baseContext}

Create an exploration summary in markdown format.

Include:
1. **Discovery**: What was found in the codebase
2. **Key Components**: Important files and their purposes
3. **Patterns & Conventions**: Code style, naming, structure
4. **Recommendations**: Next steps and which agent to use
5. **Relevant Files**: List of files to examine further

Format as clean markdown.`;

			case AgentType.DirectResponse:
				return `${baseContext}

Provide a clear, structured answer in markdown format.

Include:
1. **Answer**: Direct response to the question
2. **Explanation**: Detailed breakdown
3. **Examples**: Code examples if relevant
4. **Related Concepts**: Additional context
5. **Further Reading**: Where to learn more

Format as clean markdown.`;

			default:
				return `${baseContext}

Create an implementation plan in markdown format with clear steps and structure.`;
		}
	}

	private formatPlan(result: PlanningResult, aiPlan: string): string {
		const timestamp = new Date().toISOString();

		return `# Implementation Plan

**Generated by:** ${result.agent.name} Agent  
**Date:** ${timestamp}  
**Query:** ${result.query}

---

## Task Analysis

- **Type:** ${result.analysis.taskType}
- **Complexity:** ${result.analysis.complexity}
- **Requires Design:** ${result.analysis.requiresDesign ? 'Yes' : 'No'}
- **Estimated Files:** ${result.analysis.estimatedFiles}
- **Affected Areas:** ${result.analysis.affectedAreas.join(', ')}

## Agent Selection

**Selected Agent:** ${result.agent.name}

**Routing Reasoning:**
${result.routing.reasoning.map((r, i) => `${i + 1}. ${r}`).join('\n')}

**Confidence:** ${(result.routing.confidence * 100).toFixed(0)}%

${result.routing.alternativeAgent ? `**Alternative Agent:** ${result.routing.alternativeAgent}` : ''}

---

## Detailed Plan

${aiPlan}

---

## Agent Capabilities

**Purpose:** ${result.agent.purpose}

**Capabilities:**
${result.agent.capabilities.map(c => `- ${c}`).join('\n')}

**Limitations:**
${result.agent.limitations.map(l => `- ${l}`).join('\n')}

**Ideal For:**
${result.agent.idealFor.map(i => `- ${i}`).join('\n')}

---

*This plan was generated by the Planning Layer. Review and adjust as needed before implementation.*
`;
	}

	async savePlan(
		result: PlanningResult,
		outputDir: string = '.',
	): Promise<string> {
		const plan = await this.generatePlan(result);
		const filePath = path.join(outputDir, 'planning.md');

		await fs.writeFile(filePath, plan, 'utf-8');

		return filePath;
	}
}
